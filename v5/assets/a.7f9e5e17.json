{"title":"Subject type detection","categories":["guide"],"order":50,"meta":{"keywords":null,"description":null},"content":"<p>Let's consider an example:</p>\n<pre><code data-filename=\"defineAbility.js\" class=\"language-js\"><span class=\"hljs-keyword\">import</span> { defineAbility } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> defineAbility(<span class=\"hljs-function\">(<span class=\"hljs-params\">can</span>) =&gt;</span> {\n  can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, <span class=\"hljs-string\">&#x27;Article&#x27;</span>);\n});\n</code></pre>\n<p>We allowed everyone to read articles, now let's test it:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ability <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./defineAbility&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> article = {};\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, article);\n</code></pre>\n<p>What do you think the last line returns? It returns <code>false</code>, but why? Because <code>article</code> variable is not of <code>Article</code> type. Now you should have a question:</p>\n<h2 id=\"how-does-casl-detect-subject-type\"><a name=\"how-does-casl-detect-subject-type\" class=\"h-link\" href=\"#\"></a>How does CASL detect subject type?</h2>\n<p>If you pass an object as the 2nd argument in <code>ability.can</code>, CASL gets <code>object.constructor.modelName</code> as subject type and if this is not available, it fallbacks to <code>object.constructor.name</code>.</p>\n<p>In the example above, <code>article</code> variable contains a plain object, its constructor doesn't have <code>modelName</code>, so CASL gets its <code>constructor.name</code> as a subject type. So, in that case subject type is <code>Object</code>. There are no rules for <code>Object</code> subject type, that's why we got <code>false</code> when tried to check whether it's possible to read that object. So, how can we fix that example? The easiest way is to use special class for our <code>Article</code> model:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ability <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./defineAbility&#x27;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Article</span> </span>{}\n\n<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">new</span> Article();\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, article); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<blockquote>\n<p>Function and class names are mangled if you use <a href=\"https://terser.org/\" target=\"_blank\" rel=\"noopener nofollow\">terser</a> or <a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"noopener nofollow\">uglifyjs</a> to minify your app. That's why CASL checks <code>constructor.modelName</code> which you can define on a class to define subject type.</p>\n</blockquote>\n<p>The example above won't work in production if we use minimization. To fix it, we need to set static property on <code>Article</code> class:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ability <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./defineAbility&#x27;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Article</span> </span>{\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">modelName</span>() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Article&#x27;</span>\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">new</span> Article();\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, article); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>This is fine for backend where classes are naturally used to describe and encapsulate Domain Logic but not for frontend. Usually frontend deals with <a href=\"https://en.wikipedia.org/wiki/Data_transfer_object\" target=\"_blank\" rel=\"noopener nofollow\">DTO</a> objects (i.e., plain js objects).</p>\n<p>CASL provides 2 options to handle DTO objects:</p>\n<ol>\n<li>Use <code>subject</code> helper.</li>\n<li>Use custom subject type detection algorithm.</li>\n</ol>\n<h2 id=\"subject-helper\"><a name=\"subject-helper\" class=\"h-link\" href=\"#\"></a>subject helper</h2>\n<p>CASL provides built-in <code>subject</code> helper which sets subject type to provided object. So, the example above we can rewrite to:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { subject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ability <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./defineAbility&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> article = {};\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, subject(<span class=\"hljs-string\">&#x27;Article&#x27;</span>, article)); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>It defines readonly non-configurable and non-enumerable <code>__caslSubjectType__</code> property on the provided DTO, so it can be used in the subject's type detection algorithm.</p>\n<blockquote>\n<p>CASL will throw an exception if you try to use <code>subject</code> helper with different subject type for an object processed by the helper previously</p>\n</blockquote>\n<p>So, now you have 2 options:</p>\n<ol>\n<li>Use <code>subject</code> helper everywhere you use <code>ability.can</code> as shown in the example above.</li>\n<li>Set subject type for all <a href=\"https://en.wikipedia.org/wiki/Data_transfer_object\" target=\"_blank\" rel=\"noopener nofollow\">DTO</a>s after retrieving them from server</li>\n</ol>\n<p>So, let's see what we mean for the 2nd option:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { subject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getArticles</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">&#x27;/api/articles&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> body = <span class=\"hljs-keyword\">await</span> response.json();\n\n  <span class=\"hljs-keyword\">return</span> body.articles.map(<span class=\"hljs-function\"><span class=\"hljs-params\">article</span> =&gt;</span> subject(<span class=\"hljs-string\">&#x27;Article&#x27;</span>, article));\n}\n</code></pre>\n<blockquote>\n<p>The 2nd approach is a bit hacky because it mixes responsibilities. Now, your services coupled with CASL. This is fine for short term or small-medium apps but should be avoided for large apps</p>\n</blockquote>\n<p>Now we can safely check permissions on articles using <code>ability.can</code> without worrying about subject's type as it was defined previously.</p>\n<p>To make a code a bit more readable, you can alias <code>subject</code> to <code>a</code> or <code>an</code> depending on the context, so the example above may look like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { subject <span class=\"hljs-keyword\">as</span> an } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getArticles</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">&#x27;/api/articles&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> body = <span class=\"hljs-keyword\">await</span> response.json();\n\n  <span class=\"hljs-keyword\">return</span> body.articles.map(<span class=\"hljs-function\"><span class=\"hljs-params\">object</span> =&gt;</span> an(<span class=\"hljs-string\">&#x27;Article&#x27;</span>, object)); <span class=\"hljs-comment\">// read as &quot;an Article object&quot;</span>\n}\n</code></pre>\n<h2 id=\"custom-subject-type-detection\"><a name=\"custom-subject-type-detection\" class=\"h-link\" href=\"#\"></a>Custom subject type detection</h2>\n<p>Sometimes you will need to define your own type detection algorithm (e.g., <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener nofollow\">GraphQL</a> provides metadata field <code>__typename</code> which returns the type of the object)</p>\n<p>For such cases, we can override built-in algorithm by providing <code>detectSubjectType</code> option:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { AbilityBuilder, Ability } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> AbilityBuilder(Ability);\n\ncan(<span class=\"hljs-string\">&#x27;read&#x27;</span>, <span class=\"hljs-string\">&#x27;Article&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> ability = build({\n  <span class=\"hljs-attr\">detectSubjectType</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">object</span> =&gt;</span> object ? object.__typename : <span class=\"hljs-string\">&#x27;all&#x27;</span>\n});\n\n<span class=\"hljs-keyword\">const</span> article = { <span class=\"hljs-attr\">__typename</span>: <span class=\"hljs-string\">&#x27;Article&#x27;</span> };\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, article); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>Custom detection function must return <code>string</code> and handle the next cases:</p>\n<ul>\n<li>when <code>subject</code> is <code>undefined</code></li>\n<li>when subject is an <code>object</code></li>\n</ul>\n<p>The same can be achieved using <code>defineAbility</code> function:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { defineAbility } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> ability = defineAbility(<span class=\"hljs-function\">(<span class=\"hljs-params\">can</span>) =&gt;</span> {\n  can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, <span class=\"hljs-string\">&#x27;Article&#x27;</span>);\n}, {\n  <span class=\"hljs-attr\">detectSubjectType</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">object</span> =&gt;</span> object ? object.__typename : <span class=\"hljs-string\">&#x27;all&#x27;</span>\n});\n\n<span class=\"hljs-keyword\">const</span> article = { <span class=\"hljs-attr\">__typename</span>: <span class=\"hljs-string\">&#x27;Article&#x27;</span> };\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, article); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<h3 id=\"use-classes-as-subject-types\"><a name=\"use-classes-as-subject-types\" class=\"h-link\" href=\"#\"></a>Use classes as subject types</h3>\n<p>As we said before, it's common to use classes to model Domain Logic on backend. So, some of you may want to use classes as subject types in permission definition. To do this, we need a custom <code>detectSubjectType</code> function:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { defineAbility } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@casl/ability&#x27;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Article</span> </span>{}\n\n<span class=\"hljs-keyword\">const</span> ability = defineAbility(<span class=\"hljs-function\">(<span class=\"hljs-params\">can</span>) =&gt;</span> {\n  can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, Article);\n}, {\n  <span class=\"hljs-attr\">detectSubjectType</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">object</span> =&gt;</span> object ? object.constructor : <span class=\"hljs-literal\">null</span>\n});\n\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, <span class=\"hljs-keyword\">new</span> Article()); <span class=\"hljs-comment\">// true</span>\nability.can(<span class=\"hljs-string\">&#x27;read&#x27;</span>, Article); <span class=\"hljs-comment\">// true</span>\n</code></pre>","headings":[{"id":"how-does-casl-detect-subject-type","title":"How does CASL detect subject type?"},{"id":"subject-helper","title":"subject helper"},{"id":"custom-subject-type-detection","title":"Custom subject type detection"},{"id":"use-classes-as-subject-types","title":"Use classes as subject types"}],"id":"guide/subject-type-detection"}